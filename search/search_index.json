{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! Here you can find documentation about Nucleoid's libraries and other tools. Have a look in the navigation bar to find what you are looking for. If you want to get started making a minigame, you probably want to look at Plasmid . You can also come and chat to us on Discord in the #minigame-dev channel!","title":"Welcome!"},{"location":"#welcome","text":"Here you can find documentation about Nucleoid's libraries and other tools. Have a look in the navigation bar to find what you are looking for. If you want to get started making a minigame, you probably want to look at Plasmid . You can also come and chat to us on Discord in the #minigame-dev channel!","title":"Welcome!"},{"location":"backend/","text":"About Nucleoid uses a backend service written in rust as a central point for storing and handling data. It is currently used for the following things: HTTP API used to query information about the server and players. Discord bot and relays to link ingame chat to Discord channels. Statistics storage in a ClickHouse database Recording performance metrics from the Minecraft servers into a postgresql database, for display on Grafana.","title":"About"},{"location":"backend/#about","text":"Nucleoid uses a backend service written in rust as a central point for storing and handling data. It is currently used for the following things: HTTP API used to query information about the server and players. Discord bot and relays to link ingame chat to Discord channels. Statistics storage in a ClickHouse database Recording performance metrics from the Minecraft servers into a postgresql database, for display on Grafana.","title":"About"},{"location":"backend/http-api/","text":"HTTP API Nucleoid's backend service provides a few API endpoints for querying information about the server and players. The official backend API is available on https://api.nucleoid.xyz/ Status Server status Example GET https://api.nucleoid.xyz/status/play { \"game_version\": \"1.16.4\", \"server_ip\": \"nucleoid.xyz\", \"games\": [ { \"name\": \"Bedwars\", \"type\": \"bedwars:bedwars\", \"player_count\": 1 } ], \"players\": [ { \"name\": \"Tom_The_Geek\", \"id\": \"07e92b46-8386-4067-8f72-8ab96e606fb7\" } ] } This endpoint allows you to query the status of any of the Nucleoid servers. Currently the following servers are available to query: play : The main server on hosted on nucleoid.xyz and play.nucleoid.xyz build : The whitelisted server used for map building, hosted on build.nucleoid.xyz Field Description game_version The version of Minecraft the server is running server_ip The public IP of the server, optional games A list of all open minigames on the server players A list of all players on the server Statistics Get all player stats Example GET https://api.nucleoid.xyz/stats/player/07e92b46-8386-4067-8f72-8ab96e606fb7 { \"bedwars\": { \"damage_dealt\": 1238.8, \"final_kills\": 56.0, \"kills\": 84.0, \"blocks_placed\": 532.0, \"beds_destroyed\": 21.0 } } Allows for querying all the statistics of a player. Note The response is relatively unstructured, as players may have different combinations of games they have collected statistics for. The best way to describe the response of this endpoint is by describing the data format on the backend. The data returned is described in rust as type PlayerStatisticsResponse = HashMap < String , HashMap < String , f64 >> ; Rust's HashMap s are similar to dictionaries in other languages or objects in JavaScript. Get player stats for a game Example GET https://api.nucleoid.xyz/stats/player/07e92b46-8386-4067-8f72-8ab96e606fb7/bedwars { \"bedwars\": { \"damage_dealt\": 1238.8, \"final_kills\": 56.0, \"kills\": 84.0, \"blocks_placed\": 532.0, \"beds_destroyed\": 21.0 } } Allows for filtering the returned statistics by a particular game/namespace. It will return a response in the same format as Get all player stats , just without stats for minigames other than the specified one. Get stats for game Warning Currently, game IDs are not displayed anywhere in game or in the API, so this endpoint is relatively unusable. Example GET https://api.nucleoid.xyz/stats/game/bda420f0-b480-4f8b-bcc5-7c6c63d51643 { \"07e92b46-8386-4067-8f72-8ab96e606fb7\": { \"bedwars\": { \"final_kills\": 8, \"blocks_placed\": 76, \"beds_destroyed\": 3, \"kills\": 12, \"damage_dealt\": 154.85 } }, \"00000000-0000-0000-0000-000000000000\": { \"bedwars\": { \"teams\": 4 } } } Allows for querying the statistics after a particular game has been played. Note Like the other statistics endpoints, this data is quite unstructured, and is best described with the following: type GameStatisticsResponse = HashMap < uuid :: Uuid , HashMap < String , HashMap < String , f64 >>> ; The uuid::Uuid type can be substituted for String if your language doesn't have a specific type for UUID s.","title":"HTTP API"},{"location":"backend/http-api/#http-api","text":"Nucleoid's backend service provides a few API endpoints for querying information about the server and players. The official backend API is available on https://api.nucleoid.xyz/","title":"HTTP API"},{"location":"backend/http-api/#status","text":"","title":"Status"},{"location":"backend/http-api/#server-status","text":"Example GET https://api.nucleoid.xyz/status/play { \"game_version\": \"1.16.4\", \"server_ip\": \"nucleoid.xyz\", \"games\": [ { \"name\": \"Bedwars\", \"type\": \"bedwars:bedwars\", \"player_count\": 1 } ], \"players\": [ { \"name\": \"Tom_The_Geek\", \"id\": \"07e92b46-8386-4067-8f72-8ab96e606fb7\" } ] } This endpoint allows you to query the status of any of the Nucleoid servers. Currently the following servers are available to query: play : The main server on hosted on nucleoid.xyz and play.nucleoid.xyz build : The whitelisted server used for map building, hosted on build.nucleoid.xyz Field Description game_version The version of Minecraft the server is running server_ip The public IP of the server, optional games A list of all open minigames on the server players A list of all players on the server","title":"Server status"},{"location":"backend/http-api/#statistics","text":"","title":"Statistics"},{"location":"backend/http-api/#get-all-player-stats","text":"Example GET https://api.nucleoid.xyz/stats/player/07e92b46-8386-4067-8f72-8ab96e606fb7 { \"bedwars\": { \"damage_dealt\": 1238.8, \"final_kills\": 56.0, \"kills\": 84.0, \"blocks_placed\": 532.0, \"beds_destroyed\": 21.0 } } Allows for querying all the statistics of a player. Note The response is relatively unstructured, as players may have different combinations of games they have collected statistics for. The best way to describe the response of this endpoint is by describing the data format on the backend. The data returned is described in rust as type PlayerStatisticsResponse = HashMap < String , HashMap < String , f64 >> ; Rust's HashMap s are similar to dictionaries in other languages or objects in JavaScript.","title":"Get all player stats"},{"location":"backend/http-api/#get-player-stats-for-a-game","text":"Example GET https://api.nucleoid.xyz/stats/player/07e92b46-8386-4067-8f72-8ab96e606fb7/bedwars { \"bedwars\": { \"damage_dealt\": 1238.8, \"final_kills\": 56.0, \"kills\": 84.0, \"blocks_placed\": 532.0, \"beds_destroyed\": 21.0 } } Allows for filtering the returned statistics by a particular game/namespace. It will return a response in the same format as Get all player stats , just without stats for minigames other than the specified one.","title":"Get player stats for a game"},{"location":"backend/http-api/#get-stats-for-game","text":"Warning Currently, game IDs are not displayed anywhere in game or in the API, so this endpoint is relatively unusable. Example GET https://api.nucleoid.xyz/stats/game/bda420f0-b480-4f8b-bcc5-7c6c63d51643 { \"07e92b46-8386-4067-8f72-8ab96e606fb7\": { \"bedwars\": { \"final_kills\": 8, \"blocks_placed\": 76, \"beds_destroyed\": 3, \"kills\": 12, \"damage_dealt\": 154.85 } }, \"00000000-0000-0000-0000-000000000000\": { \"bedwars\": { \"teams\": 4 } } } Allows for querying the statistics after a particular game has been played. Note Like the other statistics endpoints, this data is quite unstructured, and is best described with the following: type GameStatisticsResponse = HashMap < uuid :: Uuid , HashMap < String , HashMap < String , f64 >>> ; The uuid::Uuid type can be substituted for String if your language doesn't have a specific type for UUID s.","title":"Get stats for game"},{"location":"plasmid/","text":"About Plasmid is a library and mod that forms the core of Nucleoid, providing a base to build minigames on top of. From the plasmid README Plasmid intends to do all the boring work relating to minigame implementation, to rather allow focus effort on just the game itself. Warning Current plasmid documentation is not up-to-date with the latest releases, including plasmid 0.5 for Minecraft 1.17. Note The current documentation is imported from the old GitHub wiki , and was originally written by Gegy.","title":"About"},{"location":"plasmid/#about","text":"Plasmid is a library and mod that forms the core of Nucleoid, providing a base to build minigames on top of. From the plasmid README Plasmid intends to do all the boring work relating to minigame implementation, to rather allow focus effort on just the game itself. Warning Current plasmid documentation is not up-to-date with the latest releases, including plasmid 0.5 for Minecraft 1.17. Note The current documentation is imported from the old GitHub wiki , and was originally written by Gegy.","title":"About"},{"location":"plasmid/getting-started/","text":"Getting Started Adding to Gradle Assuming you already have a Fabric workspace set up , the first step to setting up Plasmid will be adding it to your gradle buildscript. You will need to add the maven repository as well as the plasmid dependency. PLASMID_VERSION should be replaced with the latest version from our versions page . Info This tutorial is currently updated for Plasmid 0.5.x . repositories { maven { url = 'https://maven.nucleoid.xyz/' } } dependencies { // ... modImplementation 'xyz.nucleoid:plasmid:PLASMID_VERSION' } Creating a game type A \"game type\" ( GameType ) is the entry-point to creating a game with Plasmid: they provide a unique identifier for your game, as well as all the information needed for it to be able to call your code when the game starts. Plasmid is designed to encourage data-driven games, and works with the concept of a \"game config\". A game config is essentially a specific variation of a game type! This may involve a different map to play on, or entirely different game mechanics. A game config is simply defined as a JSON file in a datapack that references your GameType and passes along any extra data that may be useful for configuring your game. While this may be a bit more work at first, it is very powerful in allowing games to be much easier to tweak or produce multiple variations of without duplicating code. More on configs later! To register a GameType , you will need to call GameType.register() in your ModInitializer class. A call to register a GameType may look something like: GameType . register ( new Identifier ( \"plasmid_example\" , \"example\" ), ExampleGameConfig . CODEC , ExampleGame :: open ); Let's break down what is going on here: new Identifier(\"plasmid_example\", \"example\") declares the unique identifier for this game type that will be referenced by game config JSONs ExampleGameConfig.CODEC a Codec that will be used to load the game configuration from a JSON file (more on this later!) ExampleGame::open a method reference to a function that will be used to start your game when a player requests it This naturally will not compile yet: neither ExampleGame nor ExampleGameConfig exist! Let's get to that. Creating our config in code First we will create our ExampleGameConfig class, which will hold a String field that will be used as a message to send to the player when they join. Java's new Records are perfect for configs, but not required! public record ExampleGameConfig ( String greeting ) { } That's simple enough! But we're missing the CODEC field that we referenced earlier. What is that about? A Codec is a very helpful tool implemented by Mojang's DataFixerUpper library that essentially allows for convenient serialization and deserialization of a Java object to a JSON file. A more detailed explanation of Codecs by Drullkus can be found here , but for simple purposes, all you need to know is the pattern for putting them together. Essentially, a Codec describes how an object is serialized and deserialized . Simply, they can be created from a list of fields and how those fields should be serialized. It goes like this: public record ExampleGameConfig ( String greeting ) { public static final Codec < ExampleGameConfig > CODEC = RecordCodecBuilder . create ( instance -> { return instance . group ( Codec . STRING . fieldOf ( \"greeting\" ). forGetter ( ExampleGameConfig :: greeting ) ). apply ( instance , ExampleGameConfig :: new ); }); } This will correspond to a JSON file that looks something like: { \"greeting\" : \"Hello World!\" } Most things here you can ignore: you only really need to worry about what's in the instance.group(...) call, and the generic on the Codec. To look at each relevant part more specifically: Codec<ExampleGameConfig> The type of class that is being deserialized into is passed as a generic parameter to the Codec . Codec.STRING.fieldOf(...).forGetter(...) This adds a field with a given name and type that will be read from the JSON. You will notice that Codec.STRING is itself a Codec<String> ! Every field you declare will require a Codec to describe how that field should be handled. In this case, we're indicating that the greeting field should be loaded using Codec.STRING . In the same way, we could reference any other codec we create to add it as a field! This is very useful in allowing combinations of codecs to create complex structures! Codec tip: most serializable Minecraft types will hold a static CODEC field for use (e.g. BlockPos.CODEC or Identifier.CODEC ). If not, we bundle a MoreCodecs type which provides some common ones that are not included in the vanilla codebase (e.g. MoreCodecs.TEXT ). The parameter to .fieldOf() specifies the name of the field (in JSON) that this value will be read from. .forGetter() specifies how the value of a field should be read back from our config object. This is useful since codecs allow for both serialization and deserialization, and the getter is required to turn the object back into data. We can use a method reference here since we're using a record. ExampleGameConfig::new This tells the codec how to create the object once all the fields have been deserialized. This requires a method reference to the constructor for the given object with all the fields in order as they were specified! . For example, if we passed Codec.STRING.fieldOf(\"foo\") and then Codec.INT.fieldOf(\"bar) , the constructor would take a (String, int) . But here we take in one String field, and the constructor we reference also takes a single String parameter. The end result of all this Codec work is that when we create a game config, all this data will be automatically parsed from our JSON file and passed to our game code! Creating a config Now that we know what data our config should hold, we can create an actual game config JSON for Plasmid to load. All game configs need to be located in your mod resources (or datapack !) at data/<namespace>/games/<id>.json . For the purpose of a mod, the namespace should just be your mod id, and the id can be any unique name that will later be used to reference your game config from inside Minecraft. Plasmid requires only 1 JSON field from the config, while the rest is loaded as per the config codec that you set up. There are however also some additional optional fields which may be useful to define. The only required field is the type , which refers to the GameType you created earlier in namespace:path format (e.g. in our case, plasmid_example:example ). For our purposes, our game config at data/plasmid_example/games/hello_world_example.json will look like: { \"type\" : \"plasmid_example:example\" , \"greeting\" : \"Hello, World!\" } We can also add some additional builtin fields to our JSON such as a name , short_name , description , and icon . This may look like: { \"type\": \"plasmid_example:example\", \"name\": \"Hello World Example!\", \"description\": [\"Look at my cool game!\", \"It greets you when you join.\"], \"icon\": \"minecraft:apple\" // ... } name and description can also reference translation keys due to being JSON Text Components . For example, this may instead be: \"name\": {\"translation\": \"game.plasmid_example.hello_world_example\"} . A note on translations Translations are a bit non-standard in Plasmid due to it being entirely server-side! Usually translations are stored with the game client, and the server simply sends over translation keys which are then turned into relevant readable text on the client-side. Here, however, we need to instead handle translations by changing the packets that get sent to players such that they are correctly translated before the client even receives it. This is a lot of work! Luckily, this is handled by Server Translations , and we do not need to worry about it! All this actually means for you is that your language files need to go in the data folder instead of the assets folder (e.g. data/<namespace>/lang/en_us.json ). There are some default language keys we should worry about if we're not manually defining a name: gameType.<namespace>.<id> and game.<namespace>.<id> . These keys are applied for game types and game configs respectively. When resolving the readable name for a game config, both the config translation and type translation will be tested, with the type as a fallback. This means only the game type translation is strictly necessary. For example, we may define our data/plasmid_example/lang/en_us.json as: { \"gameType.plasmid_example.example\" : \"Plasmid Example!\" , \"game.plasmid_example.hello_world_example\" : \"Hello World Example!\" } Writing the code to start our game Now that we have set up a config and have told Plasmid how to read from it, we can finally write the code to actually start our game. For the purpose of this example, let's create an ExampleGame class. We will use this class to hold the state of the game as well as our ExampleGameConfig that got loaded. For now though, we just need to create this open function that we referenced to the GameType . This should look like: public class ExampleGame { public static GameOpenProcedure open ( GameOpenContext < ExampleGameConfig > context ) { // get our config that got loaded by Plasmid ExampleGameConfig config = context . config (); // create a very simple map with a stone block at (0; 64; 0) MapTemplate template = MapTemplate . createEmpty (); template . setBlockState ( new BlockPos ( 0 , 64 , 0 ), Blocks . STONE . getDefaultState ()); // create a chunk generator that will generate from this template that we just created TemplateChunkGenerator generator = new TemplateChunkGenerator ( context . server (), template ); // set up how the world that this minigame will take place in should be constructed RuntimeWorldConfig worldConfig = new RuntimeWorldConfig () . setGenerator ( generator ) . setTimeOfDay ( 6000 ); return context . openWithWorld ( worldConfig , ( activity , world ) -> { // to be implemented }); } } There is a lot to unpack here, but it's not too complex if we break it down. Our open will be called whenever a player starts this game. The function takes a GameOpenContext , which holds the data from our JSON config ( context.config() ), and must return a GameOpenProcedure , which instructs Plasmid how it should continue to set up the game. It is worth nothing that this function is run asynchronously on the thread pool, so it is safe to run whatever slow code here before the game starts. The GameOpenProcedure is created from the GameOpenContext.openWithWorld function, and takes in a RuntimeWorldConfig as well as a lambda that accepts a GameActivity and ServerWorld . A runtime world is a concept within Plasmid that represents the fully isolated and temporary world that the game takes place within. It is automatically deleted when the game finishes. When a player joins the game, their inventory will be cleared, and when they leave, it will be restored back to them. A game activity is a specific set of logic that is running within a game: this is what we will configure to change game behaviour. We can switch the activity within a game at any point. The RuntimeWorldConfig describes how this world should be created. The most important thing to be configured within here is the chunk generator: this tells the game how the world should generate. It would be possible to, for example, pass the overworld chunk generator here, but for our purpose, we're creating an empty world with a single stone block. This is handled through the convenience TemplateChunkGenerator : this takes a MapTemplate , which is just a very basic world that contains some blocks! The generator then loads from that into the world itself. Finally, we need to address what to do in the lambda with the GameActivity parameter. The code inside this lambda will run on the main server thread , and is used to run the actual game setup code. This mainly involves registering event listeners, or setting global rules. Event tip: we make use of Stimuli for handling many events in games, so any event from there can be used within Plasmid. For example: return context . openWithWorld ( worldConfig , ( activity , world ) -> { activity . deny ( GameRuleType . FALL_DAMAGE ); activity . listen ( GamePlayerEvents . ADD , player -> { // a player has been added! }); }); This code will disable fall damage for all players, as well as registering an event listener that will be called whenever a player is added to this game. However! Before we give functionality to our brilliant example game, we need to respond to the player offer event listener . This is called before any player joins the game, and is able to accept or reject that join request. Most critically, the listener defines how and where the player should be spawned into our game world. An example offer listener may look like: activity . listen ( GamePlayerEvents . OFFER , offer -> { ServerPlayerEntity player = offer . player (); return offer . accept ( world , new Vec3d ( 0.0 , 64.0 , 0.0 )) . and (() -> { player . changeGameMode ( GameMode . ADVENTURE ); }); }); That's a lot! Let's break it down: We register a listener for GamePlayerEvents.OFFER which takes an offer parameter. We get the player instance who is trying to join from the offer. We call offer.accept(...) to accept the player into the game. We pass the accept function a world and a position for the player to be teleported to. The world was passed to us above by Plasmid! We then call .and(...) on the result of .accept(...) in order to attach some additional spawn logic to be run when the player joins. In this case, that is to set the player's game mode to adventure mode as they join. Now that we have that set up, we can return to our player add listener: as of right now, we're not doing anything when it is called. We want it to send a greeting to the player when they join. Let's implement that: GameSpace gameSpace = activity . getGameSpace (); activity . listen ( GamePlayerEvents . ADD , player -> { LiteralText message = new LiteralText ( config . greeting ); gameSpace . getPlayers (). sendMessage ( message ); }); So we've added logic to send a message within the listener, but what is a GameSpace ? A GameSpace is a concept introduced by Plasmid which, as the name implies, represents the space within which a game is occurring. For all our purposes, that space is just this one dimension that the game is playing within. The GameSpace is useful for us in that it keeps track of all the players within it, as well as the ServerWorld that the game is taking place within. Here, we access the GameSpace through GameActivity.getGameSpace() . Working with players additionally goes through a different Plasmid API: a PlayerSet . A PlayerSet represents just a list of players, and it can be iterated over or queried, but additionally provides utilities for performing bulk operations over many players. For example, sending a message! Here, we use PlayerSet.sendMessage() to send our greeting to every player within the game. Tada! \ud83c\udf89 We have a working game! But before we test it, let's do some minor reorganization. With all these handlers and lambdas, our code inside createOpenProcedure is going to get quite lengthy very quickly! It would be nice if we can put all event listeners on our ExampleGame object instead. Turns out, that works just fine, and we are left with our final ExampleGame setup: public final class ExampleGame { private final ExampleGameConfig config ; private final GameSpace gameSpace ; private final ServerWorld world ; public ExampleGame ( ExampleGameConfig config , GameSpace gameSpace , ServerWorld world ) { this . config = config ; this . gameSpace = gameSpace ; this . world = world ; } public static GameOpenProcedure open ( GameOpenContext < ExampleGameConfig > context ) { // get our config that got loaded by Plasmid ExampleGameConfig config = context . config (); // create a very simple map with a stone block at (0; 64; 0) MapTemplate template = MapTemplate . createEmpty (); template . setBlockState ( new BlockPos ( 0 , 64 , 0 ), Blocks . STONE . getDefaultState ()); // create a chunk generator that will generate from this template that we just created TemplateChunkGenerator generator = new TemplateChunkGenerator ( context . server (), template ); // set up how the world that this minigame will take place in should be constructed RuntimeWorldConfig worldConfig = new RuntimeWorldConfig () . setGenerator ( generator ) . setTimeOfDay ( 6000 ); return context . openWithWorld ( worldConfig , ( activity , world ) -> { ExampleGame game = new ExampleGame ( config , activity . getGameSpace (), world ); activity . deny ( GameRuleType . FALL_DAMAGE ); activity . listen ( GamePlayerEvents . OFFER , game :: onPlayerOffer ); activity . listen ( GamePlayerEvents . ADD , game :: onPlayerAdd ); }); } private PlayerOfferResult onPlayerOffer ( PlayerOffer offer ) { ServerPlayerEntity player = offer . player (); return offer . accept ( this . world , new Vec3d ( 0.0 , 64.0 , 0.0 )) . and (() -> { player . changeGameMode ( GameMode . ADVENTURE ); }); } private void onPlayerAdd ( ServerPlayerEntity player ) { LiteralText message = new LiteralText ( this . config . greeting ); this . gameSpace . getPlayers (). sendMessage ( message ); } } Testing the game! Once everything compiles, we can finally launch up Minecraft. If our GameType is all correctly set up and game config JSON in place, once opening a world, we should be able to start our game by running: /game open <id> . (Remember, this is referencing the name of the JSON file and not the GameType!) So in our case: /game open plasmid_example:hello_world_example ...and we should be joined into our void world with a stone block with a lovely greeting! Now, any other player can join us too by running /game join or clicking the link that shows up in chat. That's it! \ud83c\udf89","title":"Getting Started"},{"location":"plasmid/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"plasmid/getting-started/#adding-to-gradle","text":"Assuming you already have a Fabric workspace set up , the first step to setting up Plasmid will be adding it to your gradle buildscript. You will need to add the maven repository as well as the plasmid dependency. PLASMID_VERSION should be replaced with the latest version from our versions page . Info This tutorial is currently updated for Plasmid 0.5.x . repositories { maven { url = 'https://maven.nucleoid.xyz/' } } dependencies { // ... modImplementation 'xyz.nucleoid:plasmid:PLASMID_VERSION' }","title":"Adding to Gradle"},{"location":"plasmid/getting-started/#creating-a-game-type","text":"A \"game type\" ( GameType ) is the entry-point to creating a game with Plasmid: they provide a unique identifier for your game, as well as all the information needed for it to be able to call your code when the game starts. Plasmid is designed to encourage data-driven games, and works with the concept of a \"game config\". A game config is essentially a specific variation of a game type! This may involve a different map to play on, or entirely different game mechanics. A game config is simply defined as a JSON file in a datapack that references your GameType and passes along any extra data that may be useful for configuring your game. While this may be a bit more work at first, it is very powerful in allowing games to be much easier to tweak or produce multiple variations of without duplicating code. More on configs later! To register a GameType , you will need to call GameType.register() in your ModInitializer class. A call to register a GameType may look something like: GameType . register ( new Identifier ( \"plasmid_example\" , \"example\" ), ExampleGameConfig . CODEC , ExampleGame :: open ); Let's break down what is going on here: new Identifier(\"plasmid_example\", \"example\") declares the unique identifier for this game type that will be referenced by game config JSONs ExampleGameConfig.CODEC a Codec that will be used to load the game configuration from a JSON file (more on this later!) ExampleGame::open a method reference to a function that will be used to start your game when a player requests it This naturally will not compile yet: neither ExampleGame nor ExampleGameConfig exist! Let's get to that.","title":"Creating a game type"},{"location":"plasmid/getting-started/#creating-our-config-in-code","text":"First we will create our ExampleGameConfig class, which will hold a String field that will be used as a message to send to the player when they join. Java's new Records are perfect for configs, but not required! public record ExampleGameConfig ( String greeting ) { } That's simple enough! But we're missing the CODEC field that we referenced earlier. What is that about? A Codec is a very helpful tool implemented by Mojang's DataFixerUpper library that essentially allows for convenient serialization and deserialization of a Java object to a JSON file. A more detailed explanation of Codecs by Drullkus can be found here , but for simple purposes, all you need to know is the pattern for putting them together. Essentially, a Codec describes how an object is serialized and deserialized . Simply, they can be created from a list of fields and how those fields should be serialized. It goes like this: public record ExampleGameConfig ( String greeting ) { public static final Codec < ExampleGameConfig > CODEC = RecordCodecBuilder . create ( instance -> { return instance . group ( Codec . STRING . fieldOf ( \"greeting\" ). forGetter ( ExampleGameConfig :: greeting ) ). apply ( instance , ExampleGameConfig :: new ); }); } This will correspond to a JSON file that looks something like: { \"greeting\" : \"Hello World!\" } Most things here you can ignore: you only really need to worry about what's in the instance.group(...) call, and the generic on the Codec. To look at each relevant part more specifically: Codec<ExampleGameConfig> The type of class that is being deserialized into is passed as a generic parameter to the Codec . Codec.STRING.fieldOf(...).forGetter(...) This adds a field with a given name and type that will be read from the JSON. You will notice that Codec.STRING is itself a Codec<String> ! Every field you declare will require a Codec to describe how that field should be handled. In this case, we're indicating that the greeting field should be loaded using Codec.STRING . In the same way, we could reference any other codec we create to add it as a field! This is very useful in allowing combinations of codecs to create complex structures! Codec tip: most serializable Minecraft types will hold a static CODEC field for use (e.g. BlockPos.CODEC or Identifier.CODEC ). If not, we bundle a MoreCodecs type which provides some common ones that are not included in the vanilla codebase (e.g. MoreCodecs.TEXT ). The parameter to .fieldOf() specifies the name of the field (in JSON) that this value will be read from. .forGetter() specifies how the value of a field should be read back from our config object. This is useful since codecs allow for both serialization and deserialization, and the getter is required to turn the object back into data. We can use a method reference here since we're using a record. ExampleGameConfig::new This tells the codec how to create the object once all the fields have been deserialized. This requires a method reference to the constructor for the given object with all the fields in order as they were specified! . For example, if we passed Codec.STRING.fieldOf(\"foo\") and then Codec.INT.fieldOf(\"bar) , the constructor would take a (String, int) . But here we take in one String field, and the constructor we reference also takes a single String parameter. The end result of all this Codec work is that when we create a game config, all this data will be automatically parsed from our JSON file and passed to our game code!","title":"Creating our config in code"},{"location":"plasmid/getting-started/#creating-a-config","text":"Now that we know what data our config should hold, we can create an actual game config JSON for Plasmid to load. All game configs need to be located in your mod resources (or datapack !) at data/<namespace>/games/<id>.json . For the purpose of a mod, the namespace should just be your mod id, and the id can be any unique name that will later be used to reference your game config from inside Minecraft. Plasmid requires only 1 JSON field from the config, while the rest is loaded as per the config codec that you set up. There are however also some additional optional fields which may be useful to define. The only required field is the type , which refers to the GameType you created earlier in namespace:path format (e.g. in our case, plasmid_example:example ). For our purposes, our game config at data/plasmid_example/games/hello_world_example.json will look like: { \"type\" : \"plasmid_example:example\" , \"greeting\" : \"Hello, World!\" } We can also add some additional builtin fields to our JSON such as a name , short_name , description , and icon . This may look like: { \"type\": \"plasmid_example:example\", \"name\": \"Hello World Example!\", \"description\": [\"Look at my cool game!\", \"It greets you when you join.\"], \"icon\": \"minecraft:apple\" // ... } name and description can also reference translation keys due to being JSON Text Components . For example, this may instead be: \"name\": {\"translation\": \"game.plasmid_example.hello_world_example\"} .","title":"Creating a config"},{"location":"plasmid/getting-started/#a-note-on-translations","text":"Translations are a bit non-standard in Plasmid due to it being entirely server-side! Usually translations are stored with the game client, and the server simply sends over translation keys which are then turned into relevant readable text on the client-side. Here, however, we need to instead handle translations by changing the packets that get sent to players such that they are correctly translated before the client even receives it. This is a lot of work! Luckily, this is handled by Server Translations , and we do not need to worry about it! All this actually means for you is that your language files need to go in the data folder instead of the assets folder (e.g. data/<namespace>/lang/en_us.json ). There are some default language keys we should worry about if we're not manually defining a name: gameType.<namespace>.<id> and game.<namespace>.<id> . These keys are applied for game types and game configs respectively. When resolving the readable name for a game config, both the config translation and type translation will be tested, with the type as a fallback. This means only the game type translation is strictly necessary. For example, we may define our data/plasmid_example/lang/en_us.json as: { \"gameType.plasmid_example.example\" : \"Plasmid Example!\" , \"game.plasmid_example.hello_world_example\" : \"Hello World Example!\" }","title":"A note on translations"},{"location":"plasmid/getting-started/#writing-the-code-to-start-our-game","text":"Now that we have set up a config and have told Plasmid how to read from it, we can finally write the code to actually start our game. For the purpose of this example, let's create an ExampleGame class. We will use this class to hold the state of the game as well as our ExampleGameConfig that got loaded. For now though, we just need to create this open function that we referenced to the GameType . This should look like: public class ExampleGame { public static GameOpenProcedure open ( GameOpenContext < ExampleGameConfig > context ) { // get our config that got loaded by Plasmid ExampleGameConfig config = context . config (); // create a very simple map with a stone block at (0; 64; 0) MapTemplate template = MapTemplate . createEmpty (); template . setBlockState ( new BlockPos ( 0 , 64 , 0 ), Blocks . STONE . getDefaultState ()); // create a chunk generator that will generate from this template that we just created TemplateChunkGenerator generator = new TemplateChunkGenerator ( context . server (), template ); // set up how the world that this minigame will take place in should be constructed RuntimeWorldConfig worldConfig = new RuntimeWorldConfig () . setGenerator ( generator ) . setTimeOfDay ( 6000 ); return context . openWithWorld ( worldConfig , ( activity , world ) -> { // to be implemented }); } } There is a lot to unpack here, but it's not too complex if we break it down. Our open will be called whenever a player starts this game. The function takes a GameOpenContext , which holds the data from our JSON config ( context.config() ), and must return a GameOpenProcedure , which instructs Plasmid how it should continue to set up the game. It is worth nothing that this function is run asynchronously on the thread pool, so it is safe to run whatever slow code here before the game starts. The GameOpenProcedure is created from the GameOpenContext.openWithWorld function, and takes in a RuntimeWorldConfig as well as a lambda that accepts a GameActivity and ServerWorld . A runtime world is a concept within Plasmid that represents the fully isolated and temporary world that the game takes place within. It is automatically deleted when the game finishes. When a player joins the game, their inventory will be cleared, and when they leave, it will be restored back to them. A game activity is a specific set of logic that is running within a game: this is what we will configure to change game behaviour. We can switch the activity within a game at any point. The RuntimeWorldConfig describes how this world should be created. The most important thing to be configured within here is the chunk generator: this tells the game how the world should generate. It would be possible to, for example, pass the overworld chunk generator here, but for our purpose, we're creating an empty world with a single stone block. This is handled through the convenience TemplateChunkGenerator : this takes a MapTemplate , which is just a very basic world that contains some blocks! The generator then loads from that into the world itself. Finally, we need to address what to do in the lambda with the GameActivity parameter. The code inside this lambda will run on the main server thread , and is used to run the actual game setup code. This mainly involves registering event listeners, or setting global rules. Event tip: we make use of Stimuli for handling many events in games, so any event from there can be used within Plasmid. For example: return context . openWithWorld ( worldConfig , ( activity , world ) -> { activity . deny ( GameRuleType . FALL_DAMAGE ); activity . listen ( GamePlayerEvents . ADD , player -> { // a player has been added! }); }); This code will disable fall damage for all players, as well as registering an event listener that will be called whenever a player is added to this game. However! Before we give functionality to our brilliant example game, we need to respond to the player offer event listener . This is called before any player joins the game, and is able to accept or reject that join request. Most critically, the listener defines how and where the player should be spawned into our game world. An example offer listener may look like: activity . listen ( GamePlayerEvents . OFFER , offer -> { ServerPlayerEntity player = offer . player (); return offer . accept ( world , new Vec3d ( 0.0 , 64.0 , 0.0 )) . and (() -> { player . changeGameMode ( GameMode . ADVENTURE ); }); }); That's a lot! Let's break it down: We register a listener for GamePlayerEvents.OFFER which takes an offer parameter. We get the player instance who is trying to join from the offer. We call offer.accept(...) to accept the player into the game. We pass the accept function a world and a position for the player to be teleported to. The world was passed to us above by Plasmid! We then call .and(...) on the result of .accept(...) in order to attach some additional spawn logic to be run when the player joins. In this case, that is to set the player's game mode to adventure mode as they join. Now that we have that set up, we can return to our player add listener: as of right now, we're not doing anything when it is called. We want it to send a greeting to the player when they join. Let's implement that: GameSpace gameSpace = activity . getGameSpace (); activity . listen ( GamePlayerEvents . ADD , player -> { LiteralText message = new LiteralText ( config . greeting ); gameSpace . getPlayers (). sendMessage ( message ); }); So we've added logic to send a message within the listener, but what is a GameSpace ? A GameSpace is a concept introduced by Plasmid which, as the name implies, represents the space within which a game is occurring. For all our purposes, that space is just this one dimension that the game is playing within. The GameSpace is useful for us in that it keeps track of all the players within it, as well as the ServerWorld that the game is taking place within. Here, we access the GameSpace through GameActivity.getGameSpace() . Working with players additionally goes through a different Plasmid API: a PlayerSet . A PlayerSet represents just a list of players, and it can be iterated over or queried, but additionally provides utilities for performing bulk operations over many players. For example, sending a message! Here, we use PlayerSet.sendMessage() to send our greeting to every player within the game. Tada! \ud83c\udf89 We have a working game! But before we test it, let's do some minor reorganization. With all these handlers and lambdas, our code inside createOpenProcedure is going to get quite lengthy very quickly! It would be nice if we can put all event listeners on our ExampleGame object instead. Turns out, that works just fine, and we are left with our final ExampleGame setup: public final class ExampleGame { private final ExampleGameConfig config ; private final GameSpace gameSpace ; private final ServerWorld world ; public ExampleGame ( ExampleGameConfig config , GameSpace gameSpace , ServerWorld world ) { this . config = config ; this . gameSpace = gameSpace ; this . world = world ; } public static GameOpenProcedure open ( GameOpenContext < ExampleGameConfig > context ) { // get our config that got loaded by Plasmid ExampleGameConfig config = context . config (); // create a very simple map with a stone block at (0; 64; 0) MapTemplate template = MapTemplate . createEmpty (); template . setBlockState ( new BlockPos ( 0 , 64 , 0 ), Blocks . STONE . getDefaultState ()); // create a chunk generator that will generate from this template that we just created TemplateChunkGenerator generator = new TemplateChunkGenerator ( context . server (), template ); // set up how the world that this minigame will take place in should be constructed RuntimeWorldConfig worldConfig = new RuntimeWorldConfig () . setGenerator ( generator ) . setTimeOfDay ( 6000 ); return context . openWithWorld ( worldConfig , ( activity , world ) -> { ExampleGame game = new ExampleGame ( config , activity . getGameSpace (), world ); activity . deny ( GameRuleType . FALL_DAMAGE ); activity . listen ( GamePlayerEvents . OFFER , game :: onPlayerOffer ); activity . listen ( GamePlayerEvents . ADD , game :: onPlayerAdd ); }); } private PlayerOfferResult onPlayerOffer ( PlayerOffer offer ) { ServerPlayerEntity player = offer . player (); return offer . accept ( this . world , new Vec3d ( 0.0 , 64.0 , 0.0 )) . and (() -> { player . changeGameMode ( GameMode . ADVENTURE ); }); } private void onPlayerAdd ( ServerPlayerEntity player ) { LiteralText message = new LiteralText ( this . config . greeting ); this . gameSpace . getPlayers (). sendMessage ( message ); } }","title":"Writing the code to start our game"},{"location":"plasmid/getting-started/#testing-the-game","text":"Once everything compiles, we can finally launch up Minecraft. If our GameType is all correctly set up and game config JSON in place, once opening a world, we should be able to start our game by running: /game open <id> . (Remember, this is referencing the name of the JSON file and not the GameType!) So in our case: /game open plasmid_example:hello_world_example ...and we should be joined into our void world with a stone block with a lovely greeting! Now, any other player can join us too by running /game join or clicking the link that shows up in chat. That's it! \ud83c\udf89","title":"Testing the game!"},{"location":"plasmid/maps/","text":"Creating a Map Any minigame needs a map for the game to take place within. This may be generated by your code- but most often, you just want to use a map that you built by hand. Plasmid introduces various tools which can be used in order to accomplish this. This page will address specifically the process of building the map and attaching various metadata that may be needed for the game to function through Map Workspaces . Opening a workspace The first step to creating a map is opening a map workspace. A map workspace is essentially just a dimension that you can build within, which can later be exported into a map template file readable by Plasmid. An empty void map workspace can be opened by running: /map open <id> (e.g. /map open bedwars:cubes ) The required id is a unique identifier for your workspace in namespace:identifier format. It should be all lowercase and cannot have spaces. You are also able to create workspaces with custom chunk generators: /map open <id> like <dimension> (e.g. /map open bedwars:nether like minecraft:nether ) Moving in and out of workspaces Once you have created a workspace, you need to be able travel between them. This is possible by running: /map join <id> , which will teleport you into that workspace dimension. Once you are in the workspace dimension, you are free to build whatever you want! Likewise, it is possible to leave a map workspace and return to your former location by running: /map leave . Setting the map bounds When exporting a map to be loaded into a game, Plasmid needs to know the area of the world which should be included. This is controlled by setting a box that encompasses your map. When you first enter a workspace, you will notice a box outline formed by particles- these are your map bounds! They can be changed in a workspace by running: /map bounds <id> <corner_1> <corner_2> . - id is the workspace id to set bounds for - corner_1 and corner_2 are the two corners of the axis-aligned bounding box Setting the map origin More often than not, you will not need to change the origin of a map workspace. Essentially, though, the map origin controls the block position that will correspond to (0; 0; 0) once the map is exported. This is useful if you built your map in the wrong place, and want to move it when the game actually starts. For example, if your map is 10 blocks too high, setting your origin to (0; 10; 0) will result in the exported map moving 10 blocks downward. This can be set through /map origin <id> <origin> - id is the workspace id to set the origin for - origin is the block position to set the origin to Be careful when setting origin to not cause your map to go out of bounds! If you set your map origin somewhere below the lower y of your map bounds, that will mean in the exported map, your bounds will be going below y=0! Working with regions Having a map that we can load for a minigame is useful, but the game logic is missing any sort of useful information about the map. For example, how can your minigame know where to spawn players, or where the bed for a specific team in bedwars is located? This is where regions come in: a region is just a named area of the map which can be used to communicate to the game code an area in which something should happen. There can be multiple regions in the map with the same name, or multiple regions with different names in the same location. The naming of regions is useful in order to identify to the game code what each region represents. Creating a region To get started with creating a region, run: /give @s plasmid:add_region . This gives you the Add Region item, which can be used to easily define regions within your world by selecting two corners. By right clicking on a block, a particle box should appear. This starts the process of defining a region by selecting the first corner. Now, as you look around, the box will shape to match the second corner. Right clicking a second time will select the current looked-at block as the second corner. Now, you can run /map region commit <marker> . This will add the highlighted region to your map with the given marker , and it should highlight with differently colored particles. When selecting a region with the Add Region item, you can additionally change the selection mode by sneaking & right clicking. This cycles through 3 modes: - offset mode: the highlighted block is the block you are looking at, offset by the side you are looking at it from (like placing a block) - exact mode: the highlighted block is the exact block your are looking at (like breaking a block) - at feet mode: the highlighted block is the block at your feet Useful region commands /map region rename all <old> <new> : renames all regions in the current workspace from old to new /map region rename here <old> <new> : renames all regions intersecting with your player in the current workspace from old to new /map region remove here : removes all regions intersecting with your player from the current workspace /map region remove at <pos> : removes all regions intersecting with the given pos from the current workspace Attaching data It may desirable to communicate more information about the map to the code than just regions. This can be done by attaching arbitrary NBT data which is later accessible by the code. Data can be either attached to a region or to the map as a whole. To work with data on a specific region, your player must be intersecting that region's bounds ! - /map region data <marker> get : prints the data for the given region - /map region data <marker> set <data> : sets the data for the given region ( this will overwrite any previously existing data! ) - /map region data <marker> merge <data> : merges the given data with the existing data on the given region It is additionally possible to pass data to the region commit command: /map region commit <marker> <data> To work with data on the global map, the commands function similarly: - /map data get : prints the data attached to the map - /map data set <data> : overwrites the existing data on the map - /map data merge <data> : merges the given data with the existing data on the map Exporting maps Once your map is complete, you will want to export it into a file that can be loaded by Plasmid. This can be done simply by running: /map export <id> . The exported map will be placed in /plasmid/exports/<namespace>/map_templates/<path>.nbt","title":"Creating a Map"},{"location":"plasmid/maps/#creating-a-map","text":"Any minigame needs a map for the game to take place within. This may be generated by your code- but most often, you just want to use a map that you built by hand. Plasmid introduces various tools which can be used in order to accomplish this. This page will address specifically the process of building the map and attaching various metadata that may be needed for the game to function through Map Workspaces .","title":"Creating a Map"},{"location":"plasmid/maps/#opening-a-workspace","text":"The first step to creating a map is opening a map workspace. A map workspace is essentially just a dimension that you can build within, which can later be exported into a map template file readable by Plasmid. An empty void map workspace can be opened by running: /map open <id> (e.g. /map open bedwars:cubes ) The required id is a unique identifier for your workspace in namespace:identifier format. It should be all lowercase and cannot have spaces. You are also able to create workspaces with custom chunk generators: /map open <id> like <dimension> (e.g. /map open bedwars:nether like minecraft:nether )","title":"Opening a workspace"},{"location":"plasmid/maps/#moving-in-and-out-of-workspaces","text":"Once you have created a workspace, you need to be able travel between them. This is possible by running: /map join <id> , which will teleport you into that workspace dimension. Once you are in the workspace dimension, you are free to build whatever you want! Likewise, it is possible to leave a map workspace and return to your former location by running: /map leave .","title":"Moving in and out of workspaces"},{"location":"plasmid/maps/#setting-the-map-bounds","text":"When exporting a map to be loaded into a game, Plasmid needs to know the area of the world which should be included. This is controlled by setting a box that encompasses your map. When you first enter a workspace, you will notice a box outline formed by particles- these are your map bounds! They can be changed in a workspace by running: /map bounds <id> <corner_1> <corner_2> . - id is the workspace id to set bounds for - corner_1 and corner_2 are the two corners of the axis-aligned bounding box","title":"Setting the map bounds"},{"location":"plasmid/maps/#setting-the-map-origin","text":"More often than not, you will not need to change the origin of a map workspace. Essentially, though, the map origin controls the block position that will correspond to (0; 0; 0) once the map is exported. This is useful if you built your map in the wrong place, and want to move it when the game actually starts. For example, if your map is 10 blocks too high, setting your origin to (0; 10; 0) will result in the exported map moving 10 blocks downward. This can be set through /map origin <id> <origin> - id is the workspace id to set the origin for - origin is the block position to set the origin to Be careful when setting origin to not cause your map to go out of bounds! If you set your map origin somewhere below the lower y of your map bounds, that will mean in the exported map, your bounds will be going below y=0!","title":"Setting the map origin"},{"location":"plasmid/maps/#working-with-regions","text":"Having a map that we can load for a minigame is useful, but the game logic is missing any sort of useful information about the map. For example, how can your minigame know where to spawn players, or where the bed for a specific team in bedwars is located? This is where regions come in: a region is just a named area of the map which can be used to communicate to the game code an area in which something should happen. There can be multiple regions in the map with the same name, or multiple regions with different names in the same location. The naming of regions is useful in order to identify to the game code what each region represents.","title":"Working with regions"},{"location":"plasmid/maps/#creating-a-region","text":"To get started with creating a region, run: /give @s plasmid:add_region . This gives you the Add Region item, which can be used to easily define regions within your world by selecting two corners. By right clicking on a block, a particle box should appear. This starts the process of defining a region by selecting the first corner. Now, as you look around, the box will shape to match the second corner. Right clicking a second time will select the current looked-at block as the second corner. Now, you can run /map region commit <marker> . This will add the highlighted region to your map with the given marker , and it should highlight with differently colored particles. When selecting a region with the Add Region item, you can additionally change the selection mode by sneaking & right clicking. This cycles through 3 modes: - offset mode: the highlighted block is the block you are looking at, offset by the side you are looking at it from (like placing a block) - exact mode: the highlighted block is the exact block your are looking at (like breaking a block) - at feet mode: the highlighted block is the block at your feet","title":"Creating a region"},{"location":"plasmid/maps/#useful-region-commands","text":"/map region rename all <old> <new> : renames all regions in the current workspace from old to new /map region rename here <old> <new> : renames all regions intersecting with your player in the current workspace from old to new /map region remove here : removes all regions intersecting with your player from the current workspace /map region remove at <pos> : removes all regions intersecting with the given pos from the current workspace","title":"Useful region commands"},{"location":"plasmid/maps/#attaching-data","text":"It may desirable to communicate more information about the map to the code than just regions. This can be done by attaching arbitrary NBT data which is later accessible by the code. Data can be either attached to a region or to the map as a whole. To work with data on a specific region, your player must be intersecting that region's bounds ! - /map region data <marker> get : prints the data for the given region - /map region data <marker> set <data> : sets the data for the given region ( this will overwrite any previously existing data! ) - /map region data <marker> merge <data> : merges the given data with the existing data on the given region It is additionally possible to pass data to the region commit command: /map region commit <marker> <data> To work with data on the global map, the commands function similarly: - /map data get : prints the data attached to the map - /map data set <data> : overwrites the existing data on the map - /map data merge <data> : merges the given data with the existing data on the map","title":"Attaching data"},{"location":"plasmid/maps/#exporting-maps","text":"Once your map is complete, you will want to export it into a file that can be loaded by Plasmid. This can be done simply by running: /map export <id> . The exported map will be placed in /plasmid/exports/<namespace>/map_templates/<path>.nbt","title":"Exporting maps"},{"location":"plasmid/statistics/","text":"Implementing statistics Warning The final statistics API is only available on 0.5 for 1.17, as some things have changed since the initial implementation in plasmid 0.4 Plasmid provides an API for allowing minigames to record statistics for their players, and can be implemented to allow leaderboards to be generated for games (soon\u2122). Before you begin This guide assumes that you have a minigame already implemented and want to add support for tracking statistics. If you simply would like to create a minigame, see the Getting Started guide . It also expects that you are on the latest version of plasmid 0.5 with statistics support. Bundles of fun (Well it might not seem fun, but its the first step for implementing statistics into your game.) The first step for implementing statistics is getting your hands on a GameStatisticsBundle , which is a class provided by plasmid that holds per-player and global statistics for your current game. You can do this quite easily within the constructor of your GameActive class like this: public class MyGameActive { /* other fields */ public final GameStatisticsBundle statistics ; private MyGameActive ( GameSpace gameSpace , /* other parameters */ ) { /* other initialization logic */ // The value passed to getStatistics should usually be the ID of your minigame/mod this . statistics = gameSpace . getStatistics ( MyGame . ID ); } /* other game logic */ } You also need to provide a translation for the name of your bundle, with the translation key in the form statistic.bundle.<namespace> . This namespace is whatever you passed into gameSpace.getStatistics() , so double check it matches. Getting some keys Time to get implementi- Oh, we still need to do something else first :/ Once you have a GameStatisticsBundle , the next step is to actually increment some statistics, and this is where the specifics can become different between games, as every game is somewhat unique. What are StatisticKeys? StatisticKey s are a type-safe identifier for a specific statistic, and internally store both an Identifier and a StorageType . Standard keys Plasmid provides several built in StatisticKey s in a conveniently named StatisticKeys class. Here are some examples: GAMES_PLAYED KILLS DAMAGE_DEALT QUICKEST_TIME Custom keys You can create your own StatisticKey s and store them in public static final fields in a dedicated class, usually named something like MyGameStatistics . public class MyGameStatistics { public static final StatisticKey < Integer > SOME_COOL_STAT = // or StatisticKey.doubleKey or StatisticKey.floatKey StatisticKey . intKey ( new Identifier ( MyGame . ID , \"some_cool_stat\" ), StatisticKey . StorageType . TOTAL ); } If you implement custom keys, you need to ensure you provide translations for their names, in the form statistic.<id namespace>.<id path> , where id namespace and id path are the namespace and path of the Identifier you passed as the first argument when creating the key. Tip If you think other minigames could use a custom StatisticKey you implement, mention it in #tools-and-libraries on Discord and it might get included in plasmid's StatisticKeys class. Incrementing statistics Now for the actually interesting part. Global and per-player statistics Per-player statistics are fairly self-explanatory; they're things like KILLS or QUICKEST_TIME that apply to a single player. Global statistics are a little different, as their values are not associated with a particular player, but with the entire game session. Global statistics can be used to store things like the number of teams in the game or the length of a course. Incrementing the statistics uses a fluent API style like the following: // For a player this . statistics . forPlayer ( player ). increment ( StatisticKeys . DEATHS , 1 ); // Or a global statistic this . statistics . global (). set ( MyGameStatistics . TEAM_COUNT , 5 ); player can be either a UUID , PlayerRef or ServerPlayerEntity . The final step is to scatter these increments around your minigame and collect statistics for whatever seems interesting for players. Finished! And then that's it, your minigame now has statistics support \ud83c\udf89! If you need a hand implementing or don't understand something, feel free to join the Discord and speak to me (@Tom_The_Geek#8559) in #minigame-dev . Extra: debugging If you want to double check that your statistics are being counted correctly, you can add -Dplasmid.debug_statistics=true to your JVM arguments and plasmid will print out a JSON formatted version of all GameStatisticBundle s at the end of any game.","title":"Implementing statistics"},{"location":"plasmid/statistics/#implementing-statistics","text":"Warning The final statistics API is only available on 0.5 for 1.17, as some things have changed since the initial implementation in plasmid 0.4 Plasmid provides an API for allowing minigames to record statistics for their players, and can be implemented to allow leaderboards to be generated for games (soon\u2122).","title":"Implementing statistics"},{"location":"plasmid/statistics/#before-you-begin","text":"This guide assumes that you have a minigame already implemented and want to add support for tracking statistics. If you simply would like to create a minigame, see the Getting Started guide . It also expects that you are on the latest version of plasmid 0.5 with statistics support.","title":"Before you begin"},{"location":"plasmid/statistics/#bundles-of-fun","text":"(Well it might not seem fun, but its the first step for implementing statistics into your game.) The first step for implementing statistics is getting your hands on a GameStatisticsBundle , which is a class provided by plasmid that holds per-player and global statistics for your current game. You can do this quite easily within the constructor of your GameActive class like this: public class MyGameActive { /* other fields */ public final GameStatisticsBundle statistics ; private MyGameActive ( GameSpace gameSpace , /* other parameters */ ) { /* other initialization logic */ // The value passed to getStatistics should usually be the ID of your minigame/mod this . statistics = gameSpace . getStatistics ( MyGame . ID ); } /* other game logic */ } You also need to provide a translation for the name of your bundle, with the translation key in the form statistic.bundle.<namespace> . This namespace is whatever you passed into gameSpace.getStatistics() , so double check it matches.","title":"Bundles of fun"},{"location":"plasmid/statistics/#getting-some-keys","text":"Time to get implementi- Oh, we still need to do something else first :/ Once you have a GameStatisticsBundle , the next step is to actually increment some statistics, and this is where the specifics can become different between games, as every game is somewhat unique. What are StatisticKeys? StatisticKey s are a type-safe identifier for a specific statistic, and internally store both an Identifier and a StorageType .","title":"Getting some keys"},{"location":"plasmid/statistics/#standard-keys","text":"Plasmid provides several built in StatisticKey s in a conveniently named StatisticKeys class. Here are some examples: GAMES_PLAYED KILLS DAMAGE_DEALT QUICKEST_TIME","title":"Standard keys"},{"location":"plasmid/statistics/#custom-keys","text":"You can create your own StatisticKey s and store them in public static final fields in a dedicated class, usually named something like MyGameStatistics . public class MyGameStatistics { public static final StatisticKey < Integer > SOME_COOL_STAT = // or StatisticKey.doubleKey or StatisticKey.floatKey StatisticKey . intKey ( new Identifier ( MyGame . ID , \"some_cool_stat\" ), StatisticKey . StorageType . TOTAL ); } If you implement custom keys, you need to ensure you provide translations for their names, in the form statistic.<id namespace>.<id path> , where id namespace and id path are the namespace and path of the Identifier you passed as the first argument when creating the key. Tip If you think other minigames could use a custom StatisticKey you implement, mention it in #tools-and-libraries on Discord and it might get included in plasmid's StatisticKeys class.","title":"Custom keys"},{"location":"plasmid/statistics/#incrementing-statistics","text":"Now for the actually interesting part. Global and per-player statistics Per-player statistics are fairly self-explanatory; they're things like KILLS or QUICKEST_TIME that apply to a single player. Global statistics are a little different, as their values are not associated with a particular player, but with the entire game session. Global statistics can be used to store things like the number of teams in the game or the length of a course. Incrementing the statistics uses a fluent API style like the following: // For a player this . statistics . forPlayer ( player ). increment ( StatisticKeys . DEATHS , 1 ); // Or a global statistic this . statistics . global (). set ( MyGameStatistics . TEAM_COUNT , 5 ); player can be either a UUID , PlayerRef or ServerPlayerEntity . The final step is to scatter these increments around your minigame and collect statistics for whatever seems interesting for players.","title":"Incrementing statistics"},{"location":"plasmid/statistics/#finished","text":"And then that's it, your minigame now has statistics support \ud83c\udf89! If you need a hand implementing or don't understand something, feel free to join the Discord and speak to me (@Tom_The_Geek#8559) in #minigame-dev .","title":"Finished!"},{"location":"plasmid/statistics/#extra-debugging","text":"If you want to double check that your statistics are being counted correctly, you can add -Dplasmid.debug_statistics=true to your JVM arguments and plasmid will print out a JSON formatted version of all GameStatisticBundle s at the end of any game.","title":"Extra: debugging"}]}